require("../shim"),require("../listen/array-changes");var GenericCollection=require("../generic-collection"),describeDequeue=require("./dequeue"),describeCollection=require("./collection"),describeOrder=require("./order"),describeMapChanges=require("./listen/map-changes");describe("Array",function(){function e(e){var t=[];return e&&e.forEach(function(e){t.set(e[0],e[1])}),t}function t(){this.length=3}describeDequeue(Array.from),describeCollection(Array.from,[1,2,3,4]),describeCollection(Array.from,[{id:0},{id:1},{id:2},{id:3}]),describeOrder(Array.from),describeMapChanges(e),Object.addEach(t.prototype,GenericCollection.prototype),t.prototype.reduce=function(e,t){return t=e(t,10,0,this),t=e(t,20,1,this),t=e(t,30,2,this),t};var n=new t;describe("get",function(){it("should return the value for a given index",function(){expect([0].get(0)).toEqual(0)}),it("should not return a named property",function(){expect(function(){[].get("length")}).toThrow()}),it("should not return a named index",function(){expect(function(){[].get("0")}).toThrow()})}),describe("find",function(){it("should find equivalent objects",function(){expect([{a:10}].find({a:10})).toEqual(0)}),it("should allow equality comparison override",function(){expect([{a:10}].find({a:10},Object.is)).toEqual(-1)})}),describe("findLast",function(){it("should find equivalent objects",function(){expect([{a:10}].findLast({a:10})).toEqual(0)}),it("should allow equality comparison override",function(){expect([{a:10}].findLast({a:10},Object.is)).toEqual(-1)}),it("should find the last of equivalent objects",function(){var e={a:10};expect([e,{a:10}].findLast(e)).toEqual(1)})}),describe("has",function(){it("should find equivalent objects",function(){expect([{a:10}].has({a:10})).toBe(!0)}),it("should not find non-contained values",function(){expect([].has(-1)).toBe(!1)}),it("should allow equality comparison override",function(){var e={};expect([{}].has(e,Object.is)).toBe(!1),expect([e].has(e,Object.is)).toBe(!0)})}),describe("add",function(){it("should add values",function(){var e=[{a:10}];e.add({a:10}),expect(e[0]).toEqual({a:10}),expect(e[1]).toEqual({a:10}),expect(e.has({a:10})).toBe(!0)})}),describe("sorted",function(){var e={foo:[1,4]},t={foo:[2,3]},n={foo:[2,3]},r={foo:[3,2]},i={foo:[4]},s=[r,t,n,e,i],o=[e,t,n,r,i],u=Function.by(function(e){return e.foo});it("should not be an in-place sort",function(){expect(s.sorted()).toNotBe(s)}),it("should sort objects by a property array",function(){expect(s.sorted(u)).toEqual(o),s.sorted(u).forEach(function(e,t){expect(e).toBe(o[t])})})}),describe("clone",function(){it("should clone with indefinite depth",function(){var e=[[[]]],t=e.clone();expect(t).toEqual(e),expect(t).toNotBe(e)}),it("should clone with depth 0",function(){var e=[];expect(e.clone(0)).toBe(e)}),it("should clone with depth 1",function(){var e=[{}];expect(e.clone(1)).toNotBe(e),expect(e.clone(1)[0]).toBe(e[0])}),it("should clone with depth 2",function(){var e=[{a:10}];expect(e.clone(2)).toNotBe(e),expect(e.clone(2)[0]).toNotBe(e[0]),expect(e.clone(2)[0]).toEqual(e[0])})}),describe("zip",function(){it("should treat holes as undefined",function(){var e=[0,1],t=[];t[1]="b",expect(e.zip(t)).toEqual([[0],[1,"b"]])})}),describe("group",function(){it("should make a histogram",function(){var e=[{x:0},{x:1},{x:2},{x:3}].group(function(e){return Math.floor(e.x/2)});expect(e).toEqual([[0,[{x:0},{x:1}]],[1,[{x:2},{x:3}]]])})})})